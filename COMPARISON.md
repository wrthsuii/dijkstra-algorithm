# Порівняння реалізацій алгоритму Дейкстри

## Огляд парадигм програмування

Цей документ містить детальне порівняння трьох реалізацій алгоритму Дейкстри в різних парадигмах програмування.

## Prolog - Логічне програмування

**Парадигма:** Декларативне логічне програмування

**Представлення даних:**
- Граф як факти: `edge(From, To, Weight)`
- Відстані як список пар: `[vertex-distance]`
- Попередники: `[vertex-previous]`

**Підхід до виконання:**
- Описуємо "що" потрібно знайти, а не "як"
- Рекурсивна обробка через предикати
- Автоматичний backtracking для пошуку рішень
- Мультипризначенність - один предикат у різних режимах

**Складність:**
- Часова: O(V²) через лінійний пошук мінімуму
- Просторова: O(V²) через створення проміжних списків

**Переваги:**
- Природне представлення графових структур
- Легко додавати/видаляти ребра через факти
- Можливість верифікації та перевірки шляхів
- Код близький до математичного опису задачі

**Недоліки:**
- Повільніше виконання порівняно з імперативними мовами
- Складно оптимізувати для великих графів
- Висока витрата пам'яті через незмінність даних

**Унікальні можливості:**
- Може працювати в режимі перевірки: `dijkstra(a, e, [a,c,f,e], 20)` → true/false
- Може знаходити всі можливі шляхи через backtracking
- Природна робота з обмеженнями (CLP)

## Python - Імперативне програмування

**Парадигма:** Імперативне об'єктно-орієнтоване програмування

**Представлення даних:**
- Граф як матриця суміжності: `graph[i][j]` = вага ребра
- Відстані як масив: `dist[vertex]`
- Оброблені вершини: `sptSet[vertex]` (boolean)
- Попередники: `parent[vertex]`

**Підхід до виконання:**
- Покрокове виконання з явним контролем стану
- Цикли for/while для ітерації
- Мутабельні структури даних
- Імперативні команди (присвоєння, оновлення)

**Складність:**
- Часова: O(V²) для базової реалізації
- Просторова: O(V²) для матриці суміжності

**Переваги:**
- Висока швидкість виконання
- Простота налагодження (легко відстежити кожен крок)
- Інтуїтивно зрозумілий порядок виконання
- Великий вибір оптимізацій (heap, різні структури даних)

**Недоліки:**
- Більше коду порівняно з декларативними підходами
- Матриця суміжності неефективна для розріджених графів
- Необхідність мапити імена вершин на індекси
- Явне управління станом може призвести до помилок

**Оптимізації:**
- З heap (priority queue): O((V+E) log V)
- Список суміжності замість матриці: O(V+E) пам'яті
- Early stopping при досягненні цільової вершини

## Haskell - Функційне програмування

**Парадигма:** Чисто функційне програмування

**Представлення даних:**
- Граф як Map: `Map Vertex [(Vertex, Weight)]`
- Відстані: `Map Vertex Weight`
- Попередники: `Map Vertex Vertex`
- Незмінні структури даних

**Підхід до виконання:**
- Композиція чистих функцій
- Рекурсія замість циклів
- Функції вищого порядку (map, fold, filter)
- Ледаче обчислення (lazy evaluation)

**Складність:**
- Часова: O(V²) для базової реалізації
- Просторова: O(V+E) для списків суміжності

**Переваги:**
- Математична коректність (легше доводити властивості)
- Відсутність побічних ефектів (referential transparency)
- Сильна статична типізація (помилки на етапі компіляції)
- Легкість паралелізації (pure functions)
- Композиційність (легко комбінувати функції)

**Недоліки:**
- Крива навчання для новачків
- Складність налагодження через lazy evaluation
- Створення нових структур замість мутації (overhead)
- Менша екосистема бібліотек порівняно з Python

**Унікальні можливості:**
- Монада Maybe для безпечної обробки відсутності шляху
- Pattern matching для елегантної обробки випадків
- Type safety - неможливо передати невірні типи

## Детальне порівняння

### Представлення графу

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| Структура | Факти edge/3 | Матриця 2D | Map з списками |
| Пам'ять | O(E) | O(V²) | O(V+E) |
| Додавання ребра | Додати факт | graph[i][j]=w | Map.insert |
| Пошук сусідів | Запит edge/3 | Цикл по рядку | Map.lookup |

### Основний алгоритм

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| Цикл | Рекурсія | while/for | Рекурсія |
| Пошук мінімуму | findall + sort | Лінійний пошук | minimumBy |
| Релаксація | Рекурсія по списку | Цикл for | foldr |
| Оновлення | Нові списки | Присвоєння | Нові Map |

### Код та читабельність

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| Розмір коду | 345 рядків | 93 рядки | 160 рядків |
| Читабельність | Висока (декларативно) | Дуже висока | Середня |
| Близькість до математики | Висока | Низька | Дуже висока |
| Легкість розуміння | Середня | Висока | Низька |

### Продуктивність

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| Швидкість | Повільно | Швидко | Середньо |
| Оптимізація | Обмежена | Багато варіантів | Компілятор оптимізує |
| Масштабування | Погано | Добре | Добре |
| Паралелізація | Складно | Можливо (GIL) | Легко |

### Типізація та безпека

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| Типізація | Динамічна | Динамічна | Статична сильна |
| Перевірка типів | Runtime | Runtime | Compile-time |
| Обробка помилок | Fail/success | Exception | Maybe/Either |
| Type safety | Низька | Низька | Висока |

## Альтернативні підходи та методи

### Інші алгоритми найкоротшого шляху

**1. Алгоритм Беллмана-Форда**
- Працює з від'ємними вагами
- Складність: O(VE)
- Повільніше, але універсальніше

**2. Алгоритм A***
- Використовує евристичну функцію h(n)
- Швидше для конкретної цільової вершини
- Потребує domain knowledge

**3. Алгоритм Флойда-Воршелла**
- Знаходить шляхи між усіма парами вершин
- Складність: O(V³)
- Ефективно для щільних графів

**4. BFS (Breadth-First Search)**
- Тільки для незважених графів
- Складність: O(V+E)
- Простіший алгоритм

### Способи оптимізації Дейкстри

**1. Черга з пріоритетом (Binary Heap)**
- Складність: O((V+E) log V)
- Значне прискорення для розріджених графів
- Легко реалізувати в Python (heapq)

**2. Fibonacci Heap**
- Теоретично оптимальна складність: O(E + V log V)
- Складна реалізація
- На практиці рідко краще binary heap

**3. Двонаправлений пошук**
- Пошук одночасно від start і end
- Зменшує кількість оброблених вершин
- Ефективно для специфічних задач

**4. Bidirectional A***
- Комбінація A* та двонаправленого пошуку
- Найшвидший для багатьох практичних задач

### Способи представлення графів

**1. Матриця суміжності** (Python)
- Пам'ять: O(V²)
- Перевірка ребра: O(1)
- Ітерація по сусідах: O(V)
- Добре для щільних графів

**2. Список суміжності** (Haskell)
- Пам'ять: O(V+E)
- Перевірка ребра: O(степінь вершини)
- Ітерація по сусідах: O(степінь вершини)
- Добре для розріджених графів

**3. Факти/предикати** (Prolog)
- Пам'ять: O(E)
- Перевірка ребра: O(E) у гіршому випадку
- Декларативний підхід
- Природно для логічного програмування

## Застосування в реальних задачах

**1. Навігаційні системи (GPS)**
- Python з heap - баланс між швидкістю та простотою
- Потрібна швидка обробка великих графів доріг
- Часто використовують A* з географічною евристикою

**2. Маршрутизація в мережах**
- Критична швидкість обробки
- Python або C++ з оптимізаціями
- Вимоги до real-time обробки

**3. Аналіз соціальних мереж**
- Prolog для складних запитів про відношення
- Можливість верифікації та логічних висновків
- Менші графи, важливіша виразність

**4. Ігрові AI**
- Haskell для функційної чистоти
- Python для швидкого прототипування
- Часто A* замість Dijkstra

**5. Оптимізація логістики**
- Python для інтеграції з іншими системами
- Потрібні додаткові обмеження (час, вантажність)
- Можливо CLP у Prolog

**6. Планування проєктів (PERT/CPM)**
- Prolog для декларативного опису залежностей
- Логічний підхід до обмежень
- Невеликі графи задач

## Висновки

**Коли використовувати Prolog:**
- Потрібна декларативність та виразність
- Важлива можливість верифікації
- Невеликі графи
- Складні логічні обмеження
- Навчальні цілі (розуміння алгоритму)

**Коли використовувати Python:**
- Продакшн системи з вимогами до швидкості
- Великі графи
- Потрібні різні оптимізації
- Інтеграція з іншими системами
- Швидке прототипування

**Коли використовувати Haskell:**
- Важлива коректність та type safety
- Потрібна паралелізація
- Математичні застосування
- Функційний стиль кодової бази
- Критична відсутність побічних ефектів

Вибір залежить від конкретної задачі, вимог до продуктивності, та контексту використання.
